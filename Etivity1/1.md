# Esercizio 1

## Domanda

Progettare degli algoritmi in pseudo codice MapReduce che prende in input un file molto grande di numeri interi e produce come output:

(a) Il numero intero più grande.
(b) La media di tutti gli interi.
(c) Lo stesso insieme di interi, ma con ogni intero che appare una sola volta.
(d) Il conteggio del numero di interi distinti nell'input.

---

## Soluzioni

### (a) Numero Intero Più Grande

**Strategia**: Utilizzare una chiave fissa per aggregare tutti i valori e trovare il massimo globale.

#### Map Function
```
map(key, value):
    // key: offset nel file
    // value: linea contenente un intero
    integer = parseInt(value)
    emit("max", integer)
```

#### Reduce Function
```
reduce(key, values):
    // key: "max"
    // values: lista di interi
    max_value = -∞
    for each value in values:
        if value > max_value:
            max_value = value
    emit(key, max_value)
```

**Output**: Una coppia (chiave, valore) = ("max", valore_massimo)

---

### (b) Media di Tutti gli Interi

**Strategia**: Calcolare separatamente la somma totale e il conteggio totale, poi combinare i risultati per ottenere la media.

#### Map Function
```
map(key, value):
    // key: offset nel file
    // value: linea contenente un intero
    integer = parseInt(value)
    emit("sum", integer)
    emit("count", 1)
```

#### Combiner Function
```
combine(key, values):
    if key == "sum":
        total = 0
        for each value in values:
            total += value
        emit(key, total)
    else if key == "count":
        count = 0
        for each value in values:
            count += value
        emit(key, count)
```

#### Reduce Function
```
reduce(key, values):
    if key == "sum":
        total_sum = 0
        for each value in values:
            total_sum += value
        emit(key, total_sum)
    else if key == "count":
        total_count = 0
        for each value in values:
            total_count += value
        emit(key, total_count)
```

#### Driver/Post-processing
```
// Dopo il job MapReduce
sum = result["sum"]
count = result["count"]
average = sum / count
output("average", average)
```

**Output**: La media calcolata come somma_totale / conteggio_totale

---

### (c) Interi Distinti (Deduplicazione)

**Strategia**: Utilizzare ogni intero come chiave, sfruttando il fatto che MapReduce raggruppa automaticamente per chiave, eliminando così i duplicati.

#### Map Function
```
map(key, value):
    // key: offset nel file
    // value: linea contenente un intero
    integer = parseInt(value)
    emit(integer, 1)
```

#### Reduce Function
```
reduce(key, values):
    // key: intero
    // values: lista di 1 (occorrenze)
    // Emette ogni intero una sola volta
    emit(key, null)
```

**Output**: Una lista di tutti gli interi distinti, ognuno apparendo esattamente una volta.

---

### (d) Conteggio Interi Distinti

#### Approccio 1: Due Job MapReduce (Raccomandato)

**Job 1 - Identificazione Interi Distinti**

*Map Function:*
```
map(key, value):
    integer = parseInt(value)
    emit(integer, 1)
```

*Reduce Function:*
```
reduce(key, values):
    // key: intero distinto
    // values: lista di occorrenze
    emit(key, 1)  // Emette 1 per ogni intero distinto
```

**Job 2 - Conteggio Finale**

*Map Function:*
```
map(key, value):
    // key: intero distinto dal Job 1
    // value: 1
    emit("distinct_count", 1)
```

*Reduce Function:*
```
reduce(key, values):
    // key: "distinct_count"
    // values: lista di 1
    count = 0
    for each value in values:
        count += value
    emit(key, count)
```

#### Approccio 2: Job Singolo (Alternativo)

**Map Function**
```
map(key, value):
    integer = parseInt(value)
    emit(integer, 1)
```

**Reduce Function**
```
reduce(key, values):
    // key: intero
    // values: lista di occorrenze
    emit("distinct", 1)  // Emette 1 per ogni intero distinto
```

**Post-Reduce Aggregation**
```
// Conta il numero di righe nell'output del reduce
distinct_count = count_output_lines()
```

**Output**: Il numero totale di interi distinti nel file.